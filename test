import os
import subprocess
import shutil
import datetime
import pipes
import getLogger as gl
def IsRemoteFileExist(remoteHost,filePath):
        resp = subprocess.call(['ssh', remoteHost, 'test -e ' + pipes.quote(filePath)])
        flag = False
        if resp == 0:
                flag = True
        else:
                flag = False
        return flag


def external_cmd(cmd, msg_in=''):
        gl.log.info('The command is :'+cmd)
        try:
                proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,)
                stdout_value, stderr_value = proc.communicate(msg_in)
		gl.log.info('stdout_value:'+stdout_value+' stderr_value:'+stderr_value)
                return stdout_value, stderr_value
        except ValueError, err:
                gl.log.error("IOError: "+ err)
                os._exit(1)

def dealFail(errorMessage):
	buildstatus = 'fail'
        returnInfo = {'status':buildstatus,'error':errorMessage}
        gl.log.info('get return value fail')
        print returnInfo
        os._exit(1)
--------------------------------------------------
#!/usr/bin/env python
#-*- coding:utf-8 -*-
import sys
sys.path.append(r'/data/bin/jenkinsJobPython')
import jenkins
import config.mod_config as mc
import os
import getLogger

reload(sys)
sys.setdefaultencoding('utf8')

INIT_CONFIG_XML = '''<?xml version='1.0' encoding='UTF-8'?>
<project>
  <keepDependencies>false</keepDependencies>
  <properties/>
  <scm class='jenkins.scm.NullSCM'/>
  <canRoam>true</canRoam>
  <disabled>false</disabled>
  <blockBuildWhenUpstreamBuilding>false</blockBuildWhenUpstreamBuilding>
  <triggers class='vector'/>
  <concurrentBuild>false</concurrentBuild>
  <builders/>
  <publishers/>
  <buildWrappers/>
</project>'''

SCM_SVN_CONFIG_XML = ''' <scm class="hudson.scm.SubversionSCM" plugin="subversion@2.5">
    <locations>
      <hudson.scm.SubversionSCM_-ModuleLocation>
        <remote></remote>
        <credentialsId>'''+mc.getConfig("jenkins", "credentialsid")+'''</credentialsId>
        <local>.</local>
        <depthOption>infinity</depthOption>
        <ignoreExternalsOption>true</ignoreExternalsOption>
      </hudson.scm.SubversionSCM_-ModuleLocation>
    </locations>
    <excludedRegions></excludedRegions>
    <includedRegions></includedRegions>
    <excludedUsers></excludedUsers>
    <excludedRevprop></excludedRevprop>
    <excludedCommitMessages></excludedCommitMessages>
    <workspaceUpdater class="hudson.scm.subversion.UpdateUpdater"/>
    <ignoreDirPropChanges>false</ignoreDirPropChanges>
    <filterChangelog>false</filterChangelog>
  </scm>'''

BUILD_MAVEN_CONFIG_XML = '''<builders>
    <hudson.tasks.Maven>
      <targets></targets>
      <mavenName></mavenName>
      <usePrivateRepository>false</usePrivateRepository>
      <settings class="jenkins.mvn.DefaultSettingsProvider"/>
      <globalSettings class="jenkins.mvn.DefaultGlobalSettingsProvider"/>
    </hudson.tasks.Maven>
  </builders>'''

BUILD_ANT_CONFIG_XML = '''<builders>
    <hudson.tasks.Ant plugin="ant@1.2">
      <targets></targets>
      <antName></antName>
    </hudson.tasks.Ant>
  </builders>'''


def isArgvNull(*argv):
	flag = False
	for ar in argv:
		if ar == '':
			getLogger.log.error(' something maybe null!:')
			print 'Error:some argvs maybe null!'
			flag = True
			return flag
                	os._exit(1)	
	return flag

#创建配置文件：build 目前仅支持 ant 、maven

def getConfigStr(svnPath,buildStyle,toolVersion,packageStyle=''):
	getLogger.log.info('svnPath:'+svnPath)
	getLogger.log.info('buildStyle:'+buildStyle)
	getLogger.log.info('toolVersion:'+toolVersion)
	getLogger.log.info('packageStyle:'+packageStyle)	
	if isArgvNull(svnPath,buildStyle,toolVersion):
		os._exit(1)
	else:
		buildResultStr = ''
        	if buildStyle == 'maven':
                	if packageStyle == '':
                        	getLogger.log.error('when choose maven for buildStyle, packageStyle can\'t be null!')
				print 'ERROR:need packageStyle war/ant for maven build!'
                        	os._exit(1)
                	buildResultStr = getBuildMavenStr(toolVersion,packageStyle)
        	elif buildStyle == 'ant':
                	buildResultStr = getBuildAntStr(toolVersion)
        	scmResultStr = getScmSvnStr(svnPath)
        	configStr = INIT_CONFIG_XML.replace("<scm class='jenkins.scm.NullSCM'/>",scmResultStr).replace("<builders/>",buildResultStr)
        	return configStr

def getScmSvnStr(svnPath):
	getLogger.log.info('svnPath:'+svnPath)
	if isArgvNull(svnPath) :
		os._exit(1)
	else:
        	scmxmlStr = r'<remote>'+svnPath+r'</remote>'
        	scmResultStr = SCM_SVN_CONFIG_XML.replace('<remote></remote>',scmxmlStr)
        	return scmResultStr

def getBuildMavenStr(toolVersion,packageStyle):
	getLogger.log.info('toolVersion:'+toolVersion)
	getLogger.log.info('packageStyle:'+packageStyle)		
	if isArgvNull(toolVersion,packageStyle):
		os._exit(1) 
       	else:
		target = ''
        	if packageStyle == 'war':
                	target = 'clean compile war:war'
        	elif packageStyle == 'jar':
                	target = 'clean install'
        	mavenStr = r'<mavenName>'+toolVersion+r'</mavenName>'
        	targetStr = r'<targets>'+target+r'</targets>'
        	buildResultStr= BUILD_MAVEN_CONFIG_XML.replace('<mavenName></mavenName>',mavenStr).replace('<targets></targets>',targetStr)
        	return buildResultStr

def getBuildAntStr(toolVersion):
	getLogger.log.info('toolVersion:'+toolVersion)
	if isArgvNull(toolVersion):
                os._exit(1)
	else:		
        	antStr = r'<antName>'+toolVersion+r'</antName>'
        	buildResultStr = BUILD_ANT_CONFIG_XML.replace('<antName></antName>',antStr)
        	return buildResultStr
---------------------------------------------------
#encoding:utf-8

import sys
sys.path.append(r'/data/bin/jenkinsJobPython')
import logging.config
from logging.handlers import RotatingFileHandler
import ConfigParser
import os
import config.mod_config as mc
import datetime

#日志设置
def logger(logPath):
	logFile = getLogFile(logPath)
	logger = logging.getLogger(logFile)
    	Rthandler = RotatingFileHandler(logFile, maxBytes=maxbytes, backupCount=backupcount)
    #这里来设置日志的级别
    #CRITICAl    50
    #ERROR    40
    #WARNING    30
    #INFO    20
    #DEBUG    10
    #NOSET    0
    #写入日志时，小于指定级别的信息将被忽略
	logger.setLevel(level)
	formatter = logging.Formatter(format)
	Rthandler.setFormatter(formatter)
	logger.addHandler(Rthandler)
	return logger


def getLogFile(logPath):
	now = datetime.datetime.now()
	isDirExistOrMkdir(logPath)
	logfile = now.strftime('makeJenkinsJob'+'_%Y%m%d_'+'log')
	logfilePath = os.path.join(logPath,logfile)
	return logfilePath

def isDirExistOrMkdir (dirName):
        if not os.path.exists(dirName):
                os.makedirs(dirName)
        else:
                exit
def getLogStart (message):
        str1=''
        for i in range (0,20):
                str1 += '#'
        ms = str1+message+str1
        return ms


format       	= mc.getConfig("log", "format").replace('@', '%')
level         	= int(mc.getConfig("log", "level"))
backupcount  	= int(mc.getConfig("log", "backupcount"))
maxbytes     	= int(mc.getConfig("log", "maxbytes"))
logPath 	= mc.getConfig("log", "logPath")
log = logger(logPath)
---------------------------------------------------
# -*- coding: utf-8 -*-
import os
import subprocess
import shutil
import datetime
import pipes
import commands

def external_cmd(cmd, msg_in=''):   
	print 'The command is :'+cmd
	try:  
		proc = subprocess.Popen(cmd, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,)        
		stdout_value, stderr_value = proc.communicate(msg_in) 
		return stdout_value, stderr_value    
	except ValueError, err: 
		print "IOError: %s" % err     
		os._exit(1)

def executeCmd2(comd) :
        print 'The command is :'+comd
    	(status, output) = commands.getstatusoutput(comd) 
        print 'execute command : '+comd+' resault:'+output
        return status



def executeCmd(comd) :
	print 'The command is :'+comd
	out = os.popen(comd)
	print 'resault:'+out.read()

def clearDirByBatch(dirPath):
	if os.path.exists(dirPath):
		delcmd='rd /s/q '+dirPath
		external_cmd(delcmd)
	else:
		print 'the dir path :',dirPath,' does not exist!'
		#os._exit(0)

def clearDirByPy(dirPath):
	if os.path.exists(dirPath):
		shutil.rmtree(dirPath)
	else:
		print 'the dir path :',dirPath,' does not exist!'
		os._exit(0)
	
def isDirExistOrMkdir (dirName):
        print 'dirName:',dirName
        if not os.path.exists(dirName):
                os.makedirs(dirName)
        else:
                print'the ',dirName,' is exists'
			
def isFileNotNull(fileName):
	flag = ""
	print 'fineName:',fileName
	if not os.path.exists(fileName) :
		flag = False
	elif not os.path.isfile(fileName):
		flag = False
	else :
		fileObject = open(fileName)
		try:
			dataNum = fileObject.read()
			if len(dataNum) == 0:
				flag = False
			else:
				flag = True
		finally:
			fileObject.close()	
	return flag

def getMaxValue(m,n):
	m = int(m)
	n = int(n)
	maxValue = ''
	if m > n:
		maxValue = m
	else:
		maxValue = n
	return maxValue

###是原来的makeDirUnderChangedir
def joinPathGetDir(filePath,fatherDir):  
	distr = ''
	##filePath 但必须是相对于当前目录的相对路径
	if os.path.isfile(filePath): 
		distr = os.path.dirname(os.path.join(fatherDir,filePath))
	else:
		print filePath ,'is null path or not a filePath'
	return distr

def writeFile(filePath,arr):
	f = open(filePath,'w')
	for i in range(0,len(arr)):
		f.write(arr[i]+'\n')
	f.close()

def addWriteFile(filePath,arr):
	f = open(filePath,'a')
	for i in range(0,len(arr)):
		f.write(arr[i]+'\n')
	f.close()

def getLastDir(incremPkgName):
	lastDir = os.path.split(incremPkgName)[-1].strip()
	return lastDir

def getLocalTime():
	localTime = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
	return str(localTime)

def writeErrorInfile(tempFile,ErrorMessage):
        if os.path.exists(tempFile):
                addWriteFile(tempFile,ErrorMessage)
        else :
                writeFile(tempFile,ErrorMessage)
        exit(1)

def IsRemoteFileExist(remoteHost,filePath):
	resp = subprocess.call(['ssh', remoteHost, 'test -e ' + pipes.quote(filePath)])
	flag = False
	if resp == 0:
		flag = True
	else:
		flag = False
	return flag

 #找出目录下面所有以suffix结尾的文件名
def getSuffixList(suffix,directory):
	#列出目录下的所有文件和文件夹
	items = os.listdir(directory)
	newlist = []
	for names in items:
        	if names.endswith(suffix):
                	newlist.append(names)
	return newlist
---------------------------------------------------
# -*- coding: utf-8 -*-
import os
import baseMethod as bm
import config.mod_config as mc


workspace = os.getenv('WORKSPACE')
jobName = os.getenv('JOB_NAME')
remoteComposePath = os.getenv('REMOTE_DATE_PATH')
imageName = os.getenv('REGISTRY')+'/'+os.getenv('USER_NAME')+'/'+os.getenv('PKG_NAME')+':'+os.getenv('BUILD_NUMBER')
tempFile=os.path.join(workspace,mc.getConfig('file', 'tempFile'))

def createComposeFile(jobName,imageName,composeFilePath):
	startContent = mc.getConfig('dockerFileCompose','startContent').split(',')
	endContent = mc.getConfig('dockerFileCompose','endContent').split(',')
	fileContent2 = ['  '+jobName+':','    image: '+imageName]
	fileContent = startContent+fileContent2+endContent
	bm.writeFile(composeFilePath,fileContent)

#生成compose文件
composeFilePath = os.path.join(workspace,jobName+'.yml')
createComposeFile(jobName,imageName,composeFilePath)
print 'create composeFile:',composeFilePath
#启动容器
host = os.getenv('HOST')
compose_cmd = 'docker-compose  -H tcp://'+str(host)+':2375 -f \"'+str(composeFilePath)+'\" up -d'
status = bm.executeCmd2(compose_cmd)
if status != 0:
	containerStartError = ['Error=containerStartError']
	bm.writeErrorInfile(tempFile,containerStartError) 
else :  
	getContainerName_cmd = 'docker-compose -H tcp://'+str(host)+':2375 -f '+str(composeFilePath)+'  ps |grep '+jobName+' | awk \'{print $1}\''
	stdout_value,stderr_value = bm.external_cmd(getContainerName_cmd)
	if 'Error' in stderr_value :
      		getContainerNameError = ['Error=getContainerNameError']
		#需要在配置文件里取tempFile
      		bm.writeErrorInfile(tempFile,getContainerNameError) 
	else :
		#把容器名写到数组里作为返回值
        	containerNameArr = ['containerName='+stdout_value.strip()]
		localTime = bm.getLocalTime()
		#把创建容器时间写到数组里作为返回值
		containerCreateTime = ['containerCreateTime='+localTime] 
		remotefilePath = os.path.join(remoteComposePath,jobName+'.yml')
		#把远程compose文件地址写到数组里作为返回值
		containerPath = ['containerPath='+remotefilePath] 
		addContent = containerNameArr+containerCreateTime+containerPath
		print 'write container return value in tempfile'
		#如果文件存在，在文件后追加，如果文件不存在，生成新文件写入其中
		if os.path.exists(tempFile) : 
        		bm.addWriteFile(tempFile,addContent)
		else :
			bm.writeFile(tempFile,addContent)
---------------------------------------------------
# -*- coding: utf-8 -*-
import os
import baseMethod as bm
import config.mod_config as mc


workspace = os.path.join(os.getenv('WORKSPACE'))

def createDockerFile(dockerDir,fileList):
	startContent = mc.getConfig('dockerFileContent','startContent').split('|')
	endContent = mc.getConfig('dockerFileContent','endContent').split('|')
	fileContent = []
	dockerFile = os.path.join(dockerDir,'Dockerfile')
	if len(fileList) >= 1 :
        	fileContent3 = []
        	for i in range(len(fileList)):
                	warPath = os.path.join(workspace,fileList[i])
                	cmd_cp = 'cp '+warPath+' '+dockerDir
                	bm.external_cmd(cmd_cp)
                	fileContent3 += ['ADD '+fileList[i]+' /usr/local/tomcat/webapps/']
        	fileContent = startContent+fileContent3+endContent
        	print 'fileContent:',fileContent
	else :
        	print 'the dir doesn\'t have war package!'
        	os._exit(1)
	if not os.path.exists(dockerFile) or not bm.isFileNotNull(dockerFile):
        	bm.writeFile(dockerFile,fileContent)




suffix = mc.getConfig('other','suffix')
#找出workspace下面所有以.war结尾的文件名
fileList = bm.getSuffixList(suffix,workspace)
dockerDirName = mc.getConfig('other','dockerDirName')
dockerDir = os.path.join(workspace,dockerDirName)
bm.isDirExistOrMkdir(dockerDir)
#生成Dockerfile文件并存放在dockerDir目录下
createDockerFile(dockerDir,fileList)
#生成返回值
localTime = bm.getLocalTime()
tempFile = os.path.join(os.getenv('WORKSPACE'),'tempfile')
imageName = ['imageName='+os.getenv('REGISTRY')+'/'+os.getenv('USER_NAME')+'/'+os.getenv('PKG_NAME')+':'+os.getenv('BUILD_NUMBER')]
imageCreateTime = ['imageCreateTime='+localTime]
tempContent = imageName+imageCreateTime
bm.writeFile(tempFile,tempContent)
-------------------------------------------------

import sys
sys.path.append(r'/data/bin/jenkinsJobPython')
import os
import config.mod_config as mc
import jenkins
import createJobMethod as cj
import getLogger as gl
import getServer as gs
import baseMethod as bm

def getReturnValue(filePath,flag):
	flagStatus = os.path.exists(filePath)
	gl.log.info('local tempFile path:'+filePath)
	if flagStatus == False:
        	errorMessage = 'no value return'
       		bm.dealFail(errorMessage)
	else :
        	dict1 = {}
        	#读取文件内容
        	f = open(filePath,'r')
		gl.log.info('read '+filePath)
        	lines = f.readlines()
        	for line in lines:
                	if line.strip():
                        	s = line.split('=')
				gl.log.info(filePath+' content:'+s[0]+' '+s[1])
                        	if s[0] == 'Error':
                                	errorMessage = s[1].strip()
                                	bm.dealFail(errorMessage)
                        	elif s[0] == 'imageName':
                                	if s[1].strip():
                                        	imageName = s[1].strip()
                                        	dict1=dict(dict1,**{'imageName':imageName})
                                	else:
                                        	errorMessage = "imageName null"
						#返回失败
                                        	bm.dealFail(errorMessage)                
                        	elif s[0] == 'imageCreateTime':
                                	if s[1].strip():
                                        	dict1=dict(dict1,**{'imageCreateTime':s[1].strip()})
                                	else:
                                        	errorMessage = "imageCreateTime null"
                                        	bm.dealFail(errorMessage)
                        	elif s[0] == 'containerName':
                                	if s[1].strip():
                                        	dict1=dict(dict1,**{'containerName':s[1].strip()})
                                	else:
                                        	errorMessage = "containerName null"
						bm.dealFail(errorMessage)
                        	elif s[0] == 'containerCreateTime':
                                	if s[1].strip():
                                        	dict1=dict(dict1,**{'containerCreateTime':s[1].strip()})
                                	else:
                                        	errorMessage = "containerCreateTime null"
                                        	bm.dealFail(errorMessage)
                        	elif s[0] == 'containerPath':
                                	if s[1].strip():
                                        	dict1=dict(dict1,**{'containerPath':s[1].strip()})
                                	else:
                                        	errorMessage = "containerPath null"
                                        	bm.dealFail(errorMessage)

        	f.close()
        	l = len(dict1)
        	if flag == '1':
                	if l != 2:
                                #错误处理
                        	errorMessage='get the number of images values is '+str(l)+' not correct!'
                        	bm.dealFail(errorMessage)
                	else :
                        	if dict1.get('imageName') == '' or dict1.get('imageCreateTime')== '':
                                	errorMessage = 'The value of imageName or imageCreateTime is null'
					#错误处理
                                	bm.dealFail(errorMessage)                
                        	else :
                                	buildstatus ='success'
                                	returnInfo = dict({'status':buildstatus},**dict1)
                                	gl.log.info(returnInfo)
                                	return returnInfo
        	elif flag == '2' :
                	if l != 5 :
                        	errorMessage='get the number of container values is '+str(l)+' not correct!'
                        	bm.dealFail(errorMessage)
                	else :
 				if dict1.get('imageName') == '' or dict1.get('imageCreateTime')== '' or dict1.get('containerName')=='' or dict1.get('containerCreateTime')=='' or dict1.get('containerPath') == '':
                                	errorMessage= 'The value of  imageName, imageCreateTime,containerName,containerCreateTime or containerPath is null'
					#错误处理
                                	bm.dealFail(errorMessage)                
                        	else :
                                	buildstatus ='success'
                                	returnInfo = dict({'status':buildstatus},**dict1)
                                	gl.log.info(returnInfo)
                                	return returnInfo

